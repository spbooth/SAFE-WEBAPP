//| Copyright - The University of Edinburgh 2011                            |
//|                                                                         |
//| Licensed under the Apache License, Version 2.0 (the "License");         |
//| you may not use this file except in compliance with the License.        |
//| You may obtain a copy of the License at                                 |
//|                                                                         |
//|    http://www.apache.org/licenses/LICENSE-2.0                           |
//|                                                                         |
//| Unless required by applicable law or agreed to in writing, software     |
//| distributed under the License is distributed on an "AS IS" BASIS,       |
//| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.|
//| See the License for the specific language governing permissions and     |
//| limitations under the License.                                          |
/*******************************************************************************
 * Copyright (c) - The University of Edinburgh 2010
 *******************************************************************************/
/*
 * Created on 22-Mar-2005 by spb
 *
 */
package uk.ac.ed.epcc.webapp.charts;

import java.util.Arrays;

import uk.ac.ed.epcc.webapp.AppContext;
import uk.ac.ed.epcc.webapp.Contexed;

/** Chart is a base class for chart generation.
 * Its essentially a facade class around underlying implementation classes (that implement the {@link ChartData} interface) to allow the underlying chart 
 * package to be swapped in and out. Useful helper methods that only use the public {@link ChartData} interface can live in the {@link Chart} object. The data within
 * a chart is represented by an object implementing the {@link SetPlot} interface that is generated by the {@link ChartData}.
 * <p>
 * Sub-classes of {@link Chart} have correspondng sub-lcasses of {@link ChartData} and {@link SetPlot}.
 * 
 * <p>
 * 
 * The data model is that data is classified into categories/sets. Each set is plotted separately
 * for example as different lines, sectors of a pie-chart or bars on a bar-chart.
 * Charts also support a set of text legends that label the sets.
 * 
 * 
 * 
 * @author spb
 * 
 */
public abstract class Chart<P extends Plot> implements Contexed{
	AppContext conn;
	private String legendName=null; // used to suply the keyname when converting a chart to a table.
	protected Chart(AppContext conn){
		this.conn=conn;
	}
	public AppContext getContext(){
		return conn;
	}
	/**
	 * Default maximum number of sets in output of sortSets. zero implies no
	 * restriction
	 */
	static final int DEFAULT_MAX = 0;

	// chart has to be valid for this class to function.
	// however we can't include it in the constructor parameters because the
	// ChartData has Chart in ITS constructor.
	// 
	// the getInstance methods for the Chart sub-classes ensure that a chartdata
	// is created asap but still give a point where different ChartData subclasses 
	// could be substituted.
	ChartData<P> chart;

	

	public ChartData<P> getChartData() {
		return chart;
	}

	

	/**
	 * create a scratch Plot not connected with any graph
	 * 
	 * @param nset
	 *            int number of sets
	 * @return Plot
	 * @throws Exception 
	 */
	public final P makeDataset(int nset) throws Exception {
		return getChartData().makeDataSet(nset);
	}

	protected void setChartData(ChartData<P> chart) {
		this.chart = chart;
	}
	
	/**
	 * Sort the sets of Dataset largest first with small sets mapped to an
	 * others category
	 * 
	 * @param other_frac
	 *            fraction of total plot below which a set is mapped to the
	 *            Others catagory
	 * 
	 */
	public final void sortSets(SetPlot p,double other_frac) {
		sortSets(p,other_frac, Chart.DEFAULT_MAX);
	}

	/**
	 * Sort the sets of Dataset largest first with small sets mapped to an
	 * others category the legends for the plots are also permuted. A plot with
	 * multiple datasets added may have additional legends so we assume the
	 * legends for this dataset are at the end.
	 * 
	 * @param other_frac
	 *            fraction of total plot below which a set is mapped to the
	 *            Others catagory
	 * @param max_plot
	 *            maximum number of sets to show including Others. zero implies
	 *            no limit.
	 */
	public final void sortSets(SetPlot p,double other_frac, int max_plot) {

		int nset = p.getNumSets();

		if (nset < 2) {
			// nothing to sort
			return;
		}
		double total = 0.0;
		double count[] = p.getCounts();
		Integer key[] = new Integer[nset];
		int perm[] = new int[nset];

		if (other_frac < 0.0 || other_frac > 1.0) {
			other_frac = 0.0;
		}

		for (int i = 0; i < nset; i++) {
			total += count[i];
		}
		if (total <= 0.0) {
			// can't sort empty sets
			return;
		}
		if (nset <= 1) {
			// can't sort if 1 or less set.
			return;
		}
		total *= other_frac;
		for (int i = 0; i < nset; i++) {
			key[i] = Integer.valueOf(i);
		}
		Arrays.sort(key, new ListSorter(count));
		// key is now a list of positions sorted by count

		// restrict to max_plot sets including Other
		// log.debug("max plot "+max_plot);
		if (max_plot > 1 && max_plot < nset - 1) {
			// thresh needed to only have max_plot items

			double override_thresh = 0.0;
			while (override_thresh == 0.0 && max_plot > 1) {
				override_thresh = count[key[nset - max_plot].intValue()];
				max_plot--;
			}
			// log.debug("override "+override_thresh+" thresh "+total);
			if (override_thresh > total) {
				total = override_thresh;
			}
		}
		// create a perm array to map the entries biggest first
		// with all values greater than the thresh mapped to the final position
		int new_nset = 0;
		int nother = 0;
		for (int i = 0; i < nset; i++) {
			int next_big = key[nset - i - 1].intValue(); // position of the next
															// biggest value
			perm[next_big] = new_nset;

			if (count[next_big] >= total) {
				new_nset++;
			} else {
				if (count[next_big] > 0.0) {
					nother++; // count non-zero others
				}
			}
		}
		if (nother > 0) {
			new_nset++;
		}
		p.permSets(new_nset, perm);

		String legs[] = p.getLegends();
		if( nother > 0 ){
			legs[legs.length-1]="Others";
			p.setLegends(legs);
		}

	}

	/**
	 * Sort the sets of Dataset largest first with small sets mapped to an
	 * others category
	 * 
	 * @param max_plot
	 *            maximum number of sets to show including Others. zero implies
	 *            no limit.
	 */
	public final void sortSets(SetPlot p, int max_plot) {
		sortSets(p,0.0, max_plot);
	}
		
	public final String getLegendName() {
		return legendName;
	}
	public final void setLegendName(String legendName) {
		this.legendName = legendName;
	}

}